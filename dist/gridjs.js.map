{"version":3,"sources":["gridjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"gridjs.js","sourceRoot":"/source/","sourcesContent":["// Relative targets\nconst ALL           = 'ALL';          // All entities in grid\nconst PREV_IN_ROW   = 'PREV_IN_ROW';  // Previous entity in row\nconst NEXT_IN_ROW   = 'NEXT_IN_ROW';  // Next entity in row\nconst PREV_ROW      = 'PREV_ROW';     // All entities in previous row\nconst ROW           = 'ROW';          // All entities in row\nconst NEXT_ROW      = 'NEXT_ROW';     // All entities in next row\nconst PREV_IN_COL   = 'PREV_IN_COL';  // Previous entity in column\nconst NEXT_IN_COL   = 'NEXT_IN_COL';  // Next entity in column\nconst PREV_COL      = 'PREV_COL';     // All entities in previous column\nconst COL           = 'COL';          // All entities in column\nconst NEXT_COL      = 'NEXT_COL';     // All entities in next column\n\n// After entity removed - actions\nconst DO_NOTHING          = 'DO_NOTHING';           // Do nothing\nconst RENEW               = 'RENEW';                // Replace with a new entity\nconst SHIFT_LEFT          = 'SHIFT_LEFT';           // Shift the entities in the row left when one is deleted\nconst SHIFT_UP            = 'SHIFT_UP';             // Shift the entities in the column up when one is deleted\nconst SHIFT_LEFT_ELSE_UP  = 'SHIFT_LEFT_ELSE_UP';   // Shift the entities to the left if there are any, otherwise shift column up\nconst SHIFT_UP_ELSE_LEFT  = 'SHIFT_UP_ELSE_LEFT';   // Shift the entities up if there are any, otherwise shift row left\n\n// Default options for new grid.\n// User may override any number of options in object passed as argument to the function.\nlet defaultOptions = {\n  autoExpand: false,\n  autoCollapse: false,\n  afterEntityRemoved: DO_NOTHING,\n\n  // Callbacks\n  userObjectChanged: null,  // (entity, newUserObject, oldUserObject)\n  entityAdded: null,        // (entity)\n  entityRemoved: null       // (entity)\n};\n\nfunction isFunction(functionToCheck) {\n  let getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Generate a uuid\n * Thanks to broofa for this method of generating a uuid\n * http://stackoverflow.com/a/2117523\n * @return {string} uuid\n */\nfunction uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n      let r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n      return v.toString(16);\n  });\n}\n\nfunction isRelativeTarget(target) {\n  return [ALL, PREV_IN_ROW, NEXT_IN_ROW, PREV_ROW, ROW, NEXT_ROW, PREV_IN_COL, NEXT_IN_COL, PREV_COL, COL, NEXT_COL].includes(target);\n}\n\nfunction isEntityId(entitiesMap, entityId) {\n  return entitiesMap.hasOwnProperty(entityId) && entitiesMap[entityId];\n}\n\nfunction isEntity(obj) {\n  return obj && obj instanceof Entity;\n}\n\n// When we remove an entity from the grid we will call a callback provided for the user's object.\n// Based on the options passed in, we can modify the bahaviour.\n\n/**\n * Create a new grid\n * @return {object}\n */\nfunction createGrid(options) {\n  let entitiesId = {};\n  let entities = [];\n  let rows = [];\n  let columns = [];\n  let grid = {};\n\n  let firstEntity = null;\n\n  /**\n   * Publish a message out to other entities in the grid.\n   * @param  {string} source   The entity ID of the message source\n   * @param  {string} target   The relative target(s), or entity ID or target for message\n   * @param  {strinf} subject  The subject\n   * @param  {object} message  The message to send\n   * @return {undefined}\n   */\n  grid.publish = function (source, target, subject, message) {\n    // Check target is valid\n    if (isRelativeTarget(target)) {\n\n    } else if (isEntityId(target)) {\n      // Send message to entity\n    }\n  };\n\n  /**\n   * [find description]\n   * @param  {[type]} iteratee [description]\n   * @return {[type]}          [description]\n   */\n  grid.find = function (iteratee) {\n    if (isFunction(iteratee)) {\n      return entities.filter(entity => iteratee(entity.userObject, entity.properties, entity.id));\n    } else {\n      return [];\n    }\n  };\n\n  grid.addEntity = function (after, space=ROW) {\n    // After must be an entity/entityId/userObject on the grid, unless this is the first entity, in which case\n    // it will be added to the first row, and the first column.\n\n    if (typeof after === 'undefined' || after === null) {\n      if (firstEntity !== null) {\n        // I'm afraid this isn't going to work out. It's not you, it's me.\n        throw new DuplicateFirstEntityException();\n      } else {\n        // Add a new entity as the first in the grid\n\n        // TODO Create an entity and add it.\n        // Surely we must be able to automatically create the first row/column\n        // even when autoExpand is not set to true.\n        // There is also the crucial question of how do we create the properties\n        // for the new entity? The properties could depend on other entities in the\n        // group, but we don't know which... needs some thinkin'.\n      }\n    }\n\n    // TODO\n    // Whatever the user has provided, we need to try and resolve it to an entity in the grid\n    // otherwise we cannot add a new entity.\n\n    /*\n    if (isEntity(after)) {\n\n    } else if (isEntityId(after)) {\n\n    }\n    */\n  };\n\n  grid.removeEntity = function (entity) {\n    // TODO\n    // Remove an entity and do the jiggery-pokery to shift things around according to the options\n  };\n\n  return grid;\n}\n\n/**\n * Entity class. Represents an item in the grid data store.\n */\nclass Entity {\n  constructor(options) {\n    this.id = uuid();\n    // Properties object can be passed to the user object when it is attached to the entity.\n    // This allows properties associated with the entity can remain in place when the user object\n    // is moved within the grid.\n    this.properties = {};\n    this.userObject = null;\n    this.options = options;\n  }\n\n  setUserObject(newUserObject) {\n    let oldUserObject = this.userObject;\n    this.userObject = newUserObject;\n\n    if (isFunction(this.options.userObjectChanged)) {\n      this.options.userObjectChanged(this.properties, newUserObject, oldUserObject);\n    }\n  }\n}\n\nclass DuplicateFirstEntityException {\n  constructor() {\n    this.name = 'DuplicateFirstEntityException';\n    this.message = 'Cannot add multiple entities as first entity in grid';\n  }\n}\n\nexport default createGrid;"]}